CCS PCM C Compiler, Version 4.104, 5967               16-dic-19 11:16

               Filename: C:\Users\PILAR\Desktop\ProyectoPICfuncional\teclado4x4.lst

               ROM used: 1708 words (21%)
                         Largest free fragment is 2048
               RAM used: 28 (8%) at main() level
                         57 (15%) worst case
               Stack:    5 locations

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   584
0003:  NOP
.................... #INCLUDE <16F887.H> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
.................... #device adc=10 
.................... #USE DELAY(CLOCK=4000000) 
*
0034:  MOVLW  48
0035:  MOVWF  04
0036:  BCF    03.7
0037:  MOVF   00,W
0038:  BTFSC  03.2
0039:  GOTO   048
003A:  MOVLW  01
003B:  MOVWF  78
003C:  CLRF   77
003D:  DECFSZ 77,F
003E:  GOTO   03D
003F:  DECFSZ 78,F
0040:  GOTO   03C
0041:  MOVLW  4A
0042:  MOVWF  77
0043:  DECFSZ 77,F
0044:  GOTO   043
0045:  GOTO   046
0046:  DECFSZ 00,F
0047:  GOTO   03A
0048:  RETURN
.................... #FUSES XT,NOPROTECT,NOWDT,NOBROWNOUT,NOPUT,NOLVP 
.................... //#DEFINE USE_PORTB_LCD TRUE 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7)   // Pines para establecer comunicacion rs232 
.................... #DEFINE USE_PORTB_KBD   //Por defecto el teclado se conecta al puerto D, 
....................                         //como el microcontrolador que se esta usando 
....................                         //no tiene puerto D se conecta al puerto B. 
....................    
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05A2:  BCF    03.6
05A3:  CLRF   20
05A4:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03E6:  CLRF   40
....................    sign = 0; 
03E7:  CLRF   3E
....................    base = 10; 
03E8:  MOVLW  0A
03E9:  MOVWF  3F
....................    result = 0; 
03EA:  CLRF   3D
03EB:  CLRF   3C
....................  
....................    if (!s) 
03EC:  MOVF   3A,W
03ED:  IORWF  3B,W
03EE:  BTFSS  03.2
03EF:  GOTO   3F4
....................       return 0; 
03F0:  MOVLW  00
03F1:  MOVWF  78
03F2:  MOVWF  79
03F3:  GOTO   519
....................    c = s[index++]; 
03F4:  MOVF   40,W
03F5:  INCF   40,F
03F6:  ADDWF  3A,W
03F7:  MOVWF  04
03F8:  BCF    03.7
03F9:  BTFSC  3B.0
03FA:  BSF    03.7
03FB:  MOVF   00,W
03FC:  MOVWF  41
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03FD:  MOVF   41,W
03FE:  SUBLW  2D
03FF:  BTFSS  03.2
0400:  GOTO   40D
....................    { 
....................       sign = 1;         // Set the sign to negative 
0401:  MOVLW  01
0402:  MOVWF  3E
....................       c = s[index++]; 
0403:  MOVF   40,W
0404:  INCF   40,F
0405:  ADDWF  3A,W
0406:  MOVWF  04
0407:  BCF    03.7
0408:  BTFSC  3B.0
0409:  BSF    03.7
040A:  MOVF   00,W
040B:  MOVWF  41
....................    } 
....................    else if (c == '+') 
040C:  GOTO   41A
040D:  MOVF   41,W
040E:  SUBLW  2B
040F:  BTFSS  03.2
0410:  GOTO   41A
....................    { 
....................       c = s[index++]; 
0411:  MOVF   40,W
0412:  INCF   40,F
0413:  ADDWF  3A,W
0414:  MOVWF  04
0415:  BCF    03.7
0416:  BTFSC  3B.0
0417:  BSF    03.7
0418:  MOVF   00,W
0419:  MOVWF  41
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
041A:  MOVF   41,W
041B:  SUBLW  2F
041C:  BTFSC  03.0
041D:  GOTO   50A
041E:  MOVF   41,W
041F:  SUBLW  39
0420:  BTFSS  03.0
0421:  GOTO   50A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0422:  MOVF   41,W
0423:  SUBLW  30
0424:  BTFSS  03.2
0425:  GOTO   446
0426:  MOVF   40,W
0427:  ADDWF  3A,W
0428:  MOVWF  04
0429:  BCF    03.7
042A:  BTFSC  3B.0
042B:  BSF    03.7
042C:  MOVF   00,W
042D:  SUBLW  78
042E:  BTFSC  03.2
042F:  GOTO   43A
0430:  MOVF   40,W
0431:  ADDWF  3A,W
0432:  MOVWF  04
0433:  BCF    03.7
0434:  BTFSC  3B.0
0435:  BSF    03.7
0436:  MOVF   00,W
0437:  SUBLW  58
0438:  BTFSS  03.2
0439:  GOTO   446
....................       { 
....................          base = 16; 
043A:  MOVLW  10
043B:  MOVWF  3F
....................          index++; 
043C:  INCF   40,F
....................          c = s[index++]; 
043D:  MOVF   40,W
043E:  INCF   40,F
043F:  ADDWF  3A,W
0440:  MOVWF  04
0441:  BCF    03.7
0442:  BTFSC  3B.0
0443:  BSF    03.7
0444:  MOVF   00,W
0445:  MOVWF  41
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0446:  MOVF   3F,W
0447:  SUBLW  0A
0448:  BTFSS  03.2
0449:  GOTO   499
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
044A:  MOVF   41,W
044B:  SUBLW  2F
044C:  BTFSC  03.0
044D:  GOTO   498
044E:  MOVF   41,W
044F:  SUBLW  39
0450:  BTFSS  03.0
0451:  GOTO   498
....................             result = 10*result + (c - '0'); 
0452:  CLRF   43
0453:  MOVLW  0A
0454:  MOVWF  42
0455:  MOVF   3D,W
0456:  MOVWF  45
0457:  MOVF   3C,W
0458:  MOVWF  44
*
0486:  MOVLW  30
0487:  SUBWF  41,W
0488:  ADDWF  78,W
0489:  MOVWF  3C
048A:  MOVF   79,W
048B:  MOVWF  3D
048C:  BTFSC  03.0
048D:  INCF   3D,F
....................             c = s[index++]; 
048E:  MOVF   40,W
048F:  INCF   40,F
0490:  ADDWF  3A,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  3B.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  MOVWF  41
....................          } 
0497:  GOTO   44A
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0498:  GOTO   50A
0499:  MOVF   3F,W
049A:  SUBLW  10
049B:  BTFSS  03.2
049C:  GOTO   50A
....................       { 
....................          c = toupper(c); 
049D:  MOVF   41,W
049E:  SUBLW  60
049F:  BTFSC  03.0
04A0:  GOTO   4A8
04A1:  MOVF   41,W
04A2:  SUBLW  7A
04A3:  BTFSS  03.0
04A4:  GOTO   4A8
04A5:  MOVF   41,W
04A6:  ANDLW  DF
04A7:  GOTO   4A9
04A8:  MOVF   41,W
04A9:  MOVWF  41
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
04AA:  MOVF   41,W
04AB:  SUBLW  2F
04AC:  BTFSC  03.0
04AD:  GOTO   4B2
04AE:  MOVF   41,W
04AF:  SUBLW  39
04B0:  BTFSC  03.0
04B1:  GOTO   4BA
04B2:  MOVF   41,W
04B3:  SUBLW  40
04B4:  BTFSC  03.0
04B5:  GOTO   50A
04B6:  MOVF   41,W
04B7:  SUBLW  46
04B8:  BTFSS  03.0
04B9:  GOTO   50A
....................             if (c >= '0' && c <= '9') 
04BA:  MOVF   41,W
04BB:  SUBLW  2F
04BC:  BTFSC  03.0
04BD:  GOTO   4DB
04BE:  MOVF   41,W
04BF:  SUBLW  39
04C0:  BTFSS  03.0
04C1:  GOTO   4DB
....................                result = (result << 4) + (c - '0'); 
04C2:  RLF    3C,W
04C3:  MOVWF  42
04C4:  RLF    3D,W
04C5:  MOVWF  43
04C6:  RLF    42,F
04C7:  RLF    43,F
04C8:  RLF    42,F
04C9:  RLF    43,F
04CA:  RLF    42,F
04CB:  RLF    43,F
04CC:  MOVLW  F0
04CD:  ANDWF  42,F
04CE:  MOVLW  30
04CF:  SUBWF  41,W
04D0:  ADDWF  42,W
04D1:  MOVWF  78
04D2:  MOVF   43,W
04D3:  MOVWF  7A
04D4:  BTFSC  03.0
04D5:  INCF   7A,F
04D6:  MOVF   78,W
04D7:  MOVWF  3C
04D8:  MOVF   7A,W
04D9:  MOVWF  3D
....................             else 
04DA:  GOTO   4F4
....................                result = (result << 4) + (c - 'A' + 10); 
04DB:  RLF    3C,W
04DC:  MOVWF  42
04DD:  RLF    3D,W
04DE:  MOVWF  43
04DF:  RLF    42,F
04E0:  RLF    43,F
04E1:  RLF    42,F
04E2:  RLF    43,F
04E3:  RLF    42,F
04E4:  RLF    43,F
04E5:  MOVLW  F0
04E6:  ANDWF  42,F
04E7:  MOVLW  41
04E8:  SUBWF  41,W
04E9:  ADDLW  0A
04EA:  ADDWF  42,W
04EB:  MOVWF  78
04EC:  MOVF   43,W
04ED:  MOVWF  7A
04EE:  BTFSC  03.0
04EF:  INCF   7A,F
04F0:  MOVF   78,W
04F1:  MOVWF  3C
04F2:  MOVF   7A,W
04F3:  MOVWF  3D
....................  
....................             c = s[index++];c = toupper(c); 
04F4:  MOVF   40,W
04F5:  INCF   40,F
04F6:  ADDWF  3A,W
04F7:  MOVWF  04
04F8:  BCF    03.7
04F9:  BTFSC  3B.0
04FA:  BSF    03.7
04FB:  MOVF   00,W
04FC:  MOVWF  41
04FD:  SUBLW  60
04FE:  BTFSC  03.0
04FF:  GOTO   507
0500:  MOVF   41,W
0501:  SUBLW  7A
0502:  BTFSS  03.0
0503:  GOTO   507
0504:  MOVF   41,W
0505:  ANDLW  DF
0506:  GOTO   508
0507:  MOVF   41,W
0508:  MOVWF  41
....................          } 
0509:  GOTO   4AA
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
050A:  MOVF   3F,W
050B:  SUBLW  0A
050C:  BTFSS  03.2
050D:  GOTO   515
050E:  DECFSZ 3E,W
050F:  GOTO   515
....................       result = -result; 
0510:  COMF   3C,F
0511:  COMF   3D,F
0512:  INCF   3C,F
0513:  BTFSC  03.2
0514:  INCF   3D,F
....................  
....................    return(result); 
0515:  MOVF   3C,W
0516:  MOVWF  78
0517:  MOVF   3D,W
0518:  MOVWF  79
.................... } 
0519:  BCF    0A.3
051A:  BCF    0A.4
051B:  GOTO   67E (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
005C:  MOVLW  0F
005D:  BSF    03.5
005E:  ANDWF  08,W
005F:  IORLW  F0
0060:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0061:  BCF    03.5
0062:  BSF    08.2
....................    delay_cycles(1); 
0063:  NOP
....................    lcd_output_enable(1); 
0064:  BSF    08.0
....................    delay_cycles(1); 
0065:  NOP
....................    high = lcd_read_nibble(); 
0066:  CALL   055
0067:  MOVF   78,W
0068:  MOVWF  4F
....................        
....................    lcd_output_enable(0); 
0069:  BCF    08.0
....................    delay_cycles(1); 
006A:  NOP
....................    lcd_output_enable(1); 
006B:  BSF    08.0
....................    delay_us(1); 
006C:  NOP
....................    low = lcd_read_nibble(); 
006D:  CALL   055
006E:  MOVF   78,W
006F:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
0070:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0071:  MOVLW  0F
0072:  BSF    03.5
0073:  ANDWF  08,W
0074:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0075:  BCF    03.5
0076:  SWAPF  4F,W
0077:  MOVWF  77
0078:  MOVLW  F0
0079:  ANDWF  77,F
007A:  MOVF   77,W
007B:  IORWF  4E,W
007C:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0055:  MOVF   08,W
0056:  MOVWF  77
0057:  SWAPF  08,W
0058:  ANDLW  0F
0059:  MOVWF  78
....................   #endif 
.................... } 
005A:  RETURN
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0049:  SWAPF  4F,W
004A:  ANDLW  F0
004B:  MOVWF  77
004C:  MOVLW  0F
004D:  ANDWF  08,W
004E:  IORWF  77,W
004F:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0050:  NOP
....................    lcd_output_enable(1); 
0051:  BSF    08.0
....................    delay_us(2); 
0052:  GOTO   053
....................    lcd_output_enable(0); 
0053:  BCF    08.0
.................... } 
0054:  RETURN
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
*
005B:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
007D:  MOVF   78,W
007E:  MOVWF  4E
007F:  BTFSC  4E.7
0080:  GOTO   05C
....................    lcd_output_rs(address); 
0081:  BTFSS  4C.0
0082:  BCF    08.1
0083:  BTFSC  4C.0
0084:  BSF    08.1
....................    delay_cycles(1); 
0085:  NOP
....................    lcd_output_rw(0); 
0086:  BCF    08.2
....................    delay_cycles(1); 
0087:  NOP
....................    lcd_output_enable(0); 
0088:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0089:  SWAPF  4D,W
008A:  MOVWF  4E
008B:  MOVLW  0F
008C:  ANDWF  4E,F
008D:  MOVF   4E,W
008E:  MOVWF  4F
008F:  CALL   049
....................    lcd_send_nibble(n & 0xf); 
0090:  MOVF   4D,W
0091:  ANDLW  0F
0092:  MOVWF  4E
0093:  MOVWF  4F
0094:  CALL   049
.................... } 
0095:  RETURN
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0096:  MOVLW  0F
0097:  BSF    03.5
0098:  ANDWF  08,W
0099:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
009A:  BCF    08.0
....................    lcd_rs_tris(); 
009B:  BCF    08.1
....................    lcd_rw_tris(); 
009C:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
009D:  BCF    03.5
009E:  BCF    08.1
....................    lcd_output_rw(0); 
009F:  BCF    08.2
....................    lcd_output_enable(0); 
00A0:  BCF    08.0
....................      
....................    delay_ms(15); 
00A1:  MOVLW  0F
00A2:  MOVWF  48
00A3:  CALL   034
....................    for(i=1;i<=3;++i) 
00A4:  MOVLW  01
00A5:  MOVWF  3A
00A6:  MOVF   3A,W
00A7:  SUBLW  03
00A8:  BTFSS  03.0
00A9:  GOTO   0B2
....................    { 
....................        lcd_send_nibble(3); 
00AA:  MOVLW  03
00AB:  MOVWF  4F
00AC:  CALL   049
....................        delay_ms(5); 
00AD:  MOVLW  05
00AE:  MOVWF  48
00AF:  CALL   034
....................    } 
00B0:  INCF   3A,F
00B1:  GOTO   0A6
....................      
....................    lcd_send_nibble(2); 
00B2:  MOVLW  02
00B3:  MOVWF  4F
00B4:  CALL   049
....................    for(i=0;i<=3;++i) 
00B5:  CLRF   3A
00B6:  MOVF   3A,W
00B7:  SUBLW  03
00B8:  BTFSS  03.0
00B9:  GOTO   0C3
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00BA:  MOVF   3A,W
00BB:  CALL   004
00BC:  MOVWF  3B
00BD:  CLRF   4C
00BE:  MOVF   3B,W
00BF:  MOVWF  4D
00C0:  CALL   05B
00C1:  INCF   3A,F
00C2:  GOTO   0B6
.................... } 
00C3:  BCF    0A.3
00C4:  BCF    0A.4
00C5:  GOTO   5BD (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
00C9:  DECFSZ 49,W
00CA:  GOTO   0CC
00CB:  GOTO   0CF
....................       address=LCD_LINE_TWO; 
00CC:  MOVLW  40
00CD:  MOVWF  4A
....................    else 
00CE:  GOTO   0D0
....................       address=0; 
00CF:  CLRF   4A
....................       
....................    address+=x-1; 
00D0:  MOVLW  01
00D1:  SUBWF  48,W
00D2:  ADDWF  4A,F
....................    lcd_send_byte(0,0x80|address); 
00D3:  MOVF   4A,W
00D4:  IORLW  80
00D5:  MOVWF  4B
00D6:  CLRF   4C
00D7:  MOVF   4B,W
00D8:  MOVWF  4D
00D9:  CALL   05B
.................... } 
00DA:  RETURN
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
00DB:  MOVF   47,W
00DC:  XORLW  0C
00DD:  BTFSC  03.2
00DE:  GOTO   0E6
00DF:  XORLW  06
00E0:  BTFSC  03.2
00E1:  GOTO   0EE
00E2:  XORLW  02
00E3:  BTFSC  03.2
00E4:  GOTO   0F4
00E5:  GOTO   0F9
....................       case '\f'   :  lcd_send_byte(0,1); 
00E6:  CLRF   4C
00E7:  MOVLW  01
00E8:  MOVWF  4D
00E9:  CALL   05B
....................                      delay_ms(2); 
00EA:  MOVLW  02
00EB:  MOVWF  48
00EC:  CALL   034
....................                      break; 
00ED:  GOTO   0FF
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EE:  MOVLW  01
00EF:  MOVWF  48
00F0:  MOVLW  02
00F1:  MOVWF  49
00F2:  CALL   0C9
00F3:  GOTO   0FF
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00F4:  CLRF   4C
00F5:  MOVLW  10
00F6:  MOVWF  4D
00F7:  CALL   05B
00F8:  GOTO   0FF
....................       
....................       default     : lcd_send_byte(1,c);     break; 
00F9:  MOVLW  01
00FA:  MOVWF  4C
00FB:  MOVF   47,W
00FC:  MOVWF  4D
00FD:  CALL   05B
00FE:  GOTO   0FF
....................    } 
.................... } 
00FF:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #INCLUDE <KBD4x4.C>  //Incluir en el encabezado el driver para 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
.................... //// KBD4x4_1.C //// 
.................... //// Controlador de escaneo de teclado genrico //// 
.................... //// //// 
.................... //// kbd_init () Debe llamarse antes que cualquier otra funcin. //// 
.................... //// //// 
.................... //// c = kbd_getc (c) Devuelve un valor clave si se presiona o / 0 si no //// 
.................... //// Esta funcin debe llamarse con frecuencia para //// 
.................... //// para no perder una pulsacin de tecla. //// 
.................... //// //// 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
.................... //// (C) Copyright 1996,2003 Servicios informticos personalizados //// 
.................... //// Este cdigo fuente solo puede ser utilizado por usuarios con licencia de CCS C //// 
.................... //// compilador. Este cdigo fuente solo se puede distribuir a otros //// 
.................... //// usuarios con licencia del compilador CCS C. Ningn otro uso, reproduccin //// 
.................... //// o la distribucin est permitida sin un permiso por escrito. //// 
.................... //// Programas derivados creados con este software en cdigo objeto //// 
.................... //// forma no estn restringidos de ninguna manera. //// 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
....................  
.................... ////////////////// Lo siguiente define el diseo del teclado en el puerto D 
....................  
.................... // Descomenta la siguiente definicin para usar el puerto B 
.................... // #define use_portb_kbd VERDADERO 
....................  
.................... // Asegrese de que el puerto utilizado tenga resistencias pull-up (o la pantalla LCD) en 
.................... // los pines de columna 
....................  
....................  
.................... #if defined (__PH__) 
.................... #if defined use_portb_kbd  
....................    #byte kbd = 0xF81 // Esto pone toda la estructura 
.................... #else 
....................    #byte kbd = 0xF83 // Esto pone toda la estructura 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd  
....................    #byte kbd = 6 // en el puerto B (en la direccin 6) 
.................... #else 
....................    #byte kbd = 8 // en el puerto D (en la direccin 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd  
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif  
....................  
....................  
....................  
.................... // Conexin del teclado: (por ejemplo, la columna 0 es B2) 
.................... // Bx: 
....................  
.................... #ifdef blue_keypad ///////////////////////////////////// Para el teclado azul 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// // Para el teclado negro 
.................... #define COL0 (1 << 4) 
.................... #define COL1 (1 << 5) 
.................... #define COL2 (1 << 6) 
.................... #define COL3 (1 << 7) 
....................  
.................... #define ROW0 (1 << 0) 
.................... #define ROW1 (1 << 1) 
.................... #define ROW2 (1 << 2) 
.................... #define ROW3 (1 << 3) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Diseo del teclado: 
.................... char const KEYS[4][4] = {{'1', '2', '3', 'A'}, 
....................                          {'4', '5', '6', 'B'}, 
....................                          {'7', '8', '9', 'C'}, 
....................                          {'*', '0', '#', 'D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33 // Establezca este nmero en apx n / 333 donde 
....................                                   // n es el nmero de veces que espera 
....................                                   // para llamar a kbd_getc cada segundo 
....................  
....................  
.................... void kbd_init () { 
.................... } 
*
00C6:  BCF    0A.3
00C7:  BCF    0A.4
00C8:  GOTO   5BE (RETURN)
....................  
.................... char kbd_getc () { 
....................    static BYTE kbd_call_count;   
*
05A5:  CLRF   26
....................    static short int kbd_down; 
05A6:  BCF    27.0
....................    static char last_key; 
05A7:  CLRF   28
....................    static BYTE col; 
05A8:  CLRF   29
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0146:  CLRF   3D
....................    if (++kbd_call_count > KBD_DEBOUNCE_FACTOR) { 
0147:  INCF   26,F
0148:  MOVF   26,W
0149:  SUBLW  21
014A:  BTFSC  03.0
014B:  GOTO   1A7
....................        switch (col) { 
014C:  MOVF   29,W
014D:  ADDLW  FC
014E:  BTFSC  03.0
014F:  GOTO   16A
0150:  ADDLW  04
0151:  GOTO   1AE
....................          case 0: set_tris_kbd(ALL_PINS&~COL0); 
0152:  MOVLW  EF
0153:  BSF    03.5
0154:  MOVWF  06
....................                     kbd = ~COL0&ALL_PINS; 
0155:  BCF    03.5
0156:  MOVWF  06
....................                     break; 
0157:  GOTO   16A
....................          case 1: set_tris_kbd (ALL_PINS & ~ COL1); 
0158:  MOVLW  DF
0159:  BSF    03.5
015A:  MOVWF  06
....................                     kbd = ~ COL1 & ALL_PINS; 
015B:  BCF    03.5
015C:  MOVWF  06
....................                     break; 
015D:  GOTO   16A
....................          case 2: set_tris_kbd (ALL_PINS & ~ COL2); 
015E:  MOVLW  BF
015F:  BSF    03.5
0160:  MOVWF  06
....................                     kbd = ~ COL2 & ALL_PINS; 
0161:  BCF    03.5
0162:  MOVWF  06
....................                     break; 
0163:  GOTO   16A
....................          case 3: set_tris_kbd (ALL_PINS & ~ COL3); 
0164:  MOVLW  7F
0165:  BSF    03.5
0166:  MOVWF  06
....................                     kbd = ~ COL3 & ALL_PINS; 
0167:  BCF    03.5
0168:  MOVWF  06
....................                     break; 
0169:  GOTO   16A
....................        } 
....................  
....................        if (kbd_down) { 
016A:  BTFSS  27.0
016B:  GOTO   176
....................          if ((kbd & (ALL_ROWS)) == (ALL_ROWS)) { 
016C:  MOVF   06,W
016D:  ANDLW  0F
016E:  SUBLW  0F
016F:  BTFSS  03.2
0170:  GOTO   175
....................            kbd_down = FALSE; 
0171:  BCF    27.0
....................            kchar = last_key; 
0172:  MOVF   28,W
0173:  MOVWF  3D
....................            last_key = '\0'; 
0174:  CLRF   28
....................          } 
....................        } else { 
0175:  GOTO   1A6
....................           if ((kbd & (ALL_ROWS)) != (ALL_ROWS)) { 
0176:  MOVF   06,W
0177:  ANDLW  0F
0178:  SUBLW  0F
0179:  BTFSC  03.2
017A:  GOTO   1A1
....................              if ((kbd & ROW0) == 0) 
017B:  MOVF   06,W
017C:  ANDLW  01
017D:  BTFSS  03.2
017E:  GOTO   181
....................                row = 0; 
017F:  CLRF   3E
....................              else if ((kbd & ROW1) == 0) 
0180:  GOTO   195
0181:  MOVF   06,W
0182:  ANDLW  02
0183:  BTFSS  03.2
0184:  GOTO   188
....................                row = 1; 
0185:  MOVLW  01
0186:  MOVWF  3E
....................              else if ((kbd & ROW2) == 0) 
0187:  GOTO   195
0188:  MOVF   06,W
0189:  ANDLW  04
018A:  BTFSS  03.2
018B:  GOTO   18F
....................                row = 2; 
018C:  MOVLW  02
018D:  MOVWF  3E
....................              else if ((kbd & ROW3) == 0) 
018E:  GOTO   195
018F:  MOVF   06,W
0190:  ANDLW  08
0191:  BTFSS  03.2
0192:  GOTO   195
....................                row = 3; 
0193:  MOVLW  03
0194:  MOVWF  3E
....................              last_key = KEYS [row] [col]; 
0195:  RLF    3E,W
0196:  MOVWF  77
0197:  RLF    77,F
0198:  MOVLW  FC
0199:  ANDWF  77,F
019A:  MOVF   77,W
019B:  ADDWF  29,W
019C:  CALL   00C
019D:  MOVWF  78
019E:  MOVWF  28
....................              kbd_down = TRUE; 
019F:  BSF    27.0
....................           } else { 
01A0:  GOTO   1A6
....................              ++ col; 
01A1:  INCF   29,F
....................              if (col == 4) 
01A2:  MOVF   29,W
01A3:  SUBLW  04
01A4:  BTFSC  03.2
....................                col = 0; 
01A5:  CLRF   29
....................           } 
....................        } 
....................       kbd_call_count = 0; 
01A6:  CLRF   26
....................    } 
....................   set_tris_kbd (ALL_PINS); 
01A7:  MOVLW  FF
01A8:  BSF    03.5
01A9:  MOVWF  06
....................   return (kchar); 
01AA:  BCF    03.5
01AB:  MOVF   3D,W
01AC:  MOVWF  78
.................... } 
01AD:  RETURN
....................  
....................                       //manejar el teclado telefnico MODIFICADO 
.................... #use     standard_io(b)  
.................... #define  KEYHIT_DELAY   200    //Tiempo de espera del teclado en milisegundos 
.................... #byte PORTB= 6 
.................... #byte PORTC= 7 
.................... #BYTE PORTA= 5 
.................... #BYTE PORTD= 8 
....................   
.................... long bits;     //Variable almacena los bits 
.................... float tem;     //Almacena la temperatura 
....................  
....................  
....................   INT DIR; 
....................  
.................... /*===========================================================================*/ 
.................... /*=======================       FUNCION TECLA         =======================*/ 
.................... /*===========================================================================*/ 
.................... //Funcion encargada de esperar a que se presione una tecla  
.................... char tecla(void){ 
....................    char c; 
....................    do{ //espera hasta que se presione una tecla 
....................       c=kbd_getc(); //Captura valor del teclado 
....................      } 
....................    while(c=='\0'); 
....................    return(c); 
.................... } 
....................  
.................... /*===========================================================================*/ 
.................... /*=======================    FUNCION TECLA CON TIMER  =======================*/ 
.................... /*===========================================================================*/ 
.................... // Pregunta por una Tecla por un tiempo, si no hay actividad, deja de preguntar 
.................... // y deja que el PIC continue con su trabajo 
....................  
.................... char tecla_time(void) { 
*
01B6:  CLRF   3A
....................    char c='\0'; 
....................    unsigned int16 timeout; 
....................    timeout=0; 
01B7:  CLRF   3C
01B8:  CLRF   3B
....................    c=kbd_getc(); //Captura valor del teclado 
01B9:  CALL   146
01BA:  MOVF   78,W
01BB:  MOVWF  3A
....................    while(c=='\0' && (++timeout< (KEYHIT_DELAY*100))) 
....................    { 
01BC:  MOVF   3A,F
01BD:  BTFSS  03.2
01BE:  GOTO   1D4
01BF:  INCF   3B,F
01C0:  BTFSC  03.2
01C1:  INCF   3C,F
01C2:  MOVF   3C,W
01C3:  SUBLW  4E
01C4:  BTFSS  03.0
01C5:  GOTO   1D4
01C6:  BTFSS  03.2
01C7:  GOTO   1CC
01C8:  MOVF   3B,W
01C9:  SUBLW  1F
01CA:  BTFSS  03.0
01CB:  GOTO   1D4
....................       delay_us(10); 
01CC:  MOVLW  03
01CD:  MOVWF  77
01CE:  DECFSZ 77,F
01CF:  GOTO   1CE
....................       c=kbd_getc(); //Captura valor del teclado 
01D0:  CALL   146
01D1:  MOVF   78,W
01D2:  MOVWF  3A
....................    } 
01D3:  GOTO   1BC
....................    return(c); 
01D4:  MOVF   3A,W
01D5:  MOVWF  78
.................... } 
01D6:  BCF    0A.3
01D7:  BCF    0A.4
01D8:  GOTO   618 (RETURN)
....................  
.................... /*===========================================================================*/ 
.................... /*=======================       PROGRAMA PRINCIPAL    =======================*/ 
.................... /*===========================================================================*/ 
....................  
.................... VOID MAIN() 
.................... { 
*
0584:  CLRF   04
0585:  BCF    03.7
0586:  MOVLW  1F
0587:  ANDWF  03,F
0588:  BSF    03.5
0589:  BSF    03.6
058A:  BCF    07.3
058B:  MOVLW  19
058C:  BCF    03.6
058D:  MOVWF  19
058E:  MOVLW  A6
058F:  MOVWF  18
0590:  MOVLW  90
0591:  BCF    03.5
0592:  MOVWF  18
0593:  BSF    03.5
0594:  BSF    03.6
0595:  MOVF   09,W
0596:  ANDLW  C0
0597:  MOVWF  09
0598:  BCF    03.6
0599:  BCF    1F.4
059A:  BCF    1F.5
059B:  MOVLW  00
059C:  BSF    03.6
059D:  MOVWF  08
059E:  BCF    03.5
059F:  CLRF   07
05A0:  CLRF   08
05A1:  CLRF   09
....................   CHAR K; 
....................    
....................    char aux[2];//declaramos una variable auxiliar para guardar datos del teclado 
....................     
....................     
....................    port_b_pullups (0xFF);  //Utiliza las resistencias PULL UP internas del puerto B 
*
05AB:  MOVLW  FF
05AC:  BSF    03.5
05AD:  MOVWF  15
05AE:  BCF    01.7
....................     
....................    set_tris_a(0b00000001);          //Pongo el RA0 como entrada 
05AF:  MOVLW  01
05B0:  MOVWF  05
....................    SET_TRIS_B(1); 
05B1:  MOVWF  06
....................    SET_TRIS_C(0);    //Puerto C como Salida 
05B2:  MOVLW  00
05B3:  MOVWF  07
05B4:  BCF    03.5
05B5:  MOVWF  31
....................     
....................    setup_adc(adc_clock_internal);   //Selecciono reloj interno para conversion 
05B6:  BSF    1F.6
05B7:  BSF    1F.7
05B8:  BSF    03.5
05B9:  BSF    1F.7
05BA:  BCF    03.5
05BB:  BSF    1F.0
....................     
....................    LCD_INIT();       //Inicializar el driver del lcd 
05BC:  GOTO   096
....................    KBD_INIT();       //Inicializar el driver del teclado 
05BD:  GOTO   0C6
....................    LCD_PUTC("\f");   //Limpia el LCD 
05BE:  MOVLW  25
05BF:  BSF    03.6
05C0:  MOVWF  0D
05C1:  MOVLW  00
05C2:  MOVWF  0F
05C3:  BCF    03.6
05C4:  CALL   100
....................     
....................     
....................     
....................    WHILE(1) 
....................    { 
....................       int i = 0;//val del vector 
05C5:  CLRF   35
....................       DIR=9; 
05C6:  MOVLW  09
05C7:  MOVWF  30
....................       LCD_GOTOXY(1,2);  //Ubica el cursor del LCD 
05C8:  MOVLW  01
05C9:  MOVWF  48
05CA:  MOVLW  02
05CB:  MOVWF  49
05CC:  CALL   0C9
....................       LCD_PUTC("Temp.A= "); 
05CD:  MOVLW  26
05CE:  BSF    03.6
05CF:  MOVWF  0D
05D0:  MOVLW  00
05D1:  MOVWF  0F
05D2:  BCF    03.6
05D3:  CALL   100
....................       LCD_GOTOXY(1,2);  //Ubica el cursor del LCD 
05D4:  MOVLW  01
05D5:  MOVWF  48
05D6:  MOVLW  02
05D7:  MOVWF  49
05D8:  CALL   0C9
....................       aux="";//valor auxiliar para comparar temperatura iniciado en 100 para que se apague el ventilador 
05D9:  CLRF   3A
05DA:  CLRF   3B
05DB:  MOVLW  33
05DC:  MOVWF  04
05DD:  BCF    03.7
05DE:  MOVF   3A,W
05DF:  ADDWF  04,F
05E0:  MOVF   3B,W
05E1:  CALL   020
05E2:  MOVWF  00
05E3:  IORLW  00
05E4:  BTFSC  03.2
05E5:  GOTO   5E9
05E6:  INCF   3B,F
05E7:  INCF   3A,F
05E8:  GOTO   5DB
....................       while (DIR < 17) 
....................       { 
05E9:  MOVF   30,W
05EA:  SUBLW  10
05EB:  BTFSS  03.0
05EC:  GOTO   6AA
....................             if(DIR <= 10){ 
05ED:  MOVF   30,W
05EE:  SUBLW  0A
05EF:  BTFSS  03.0
05F0:  GOTO   610
....................                if(k!='\0'){ 
05F1:  MOVF   32,F
05F2:  BTFSC  03.2
05F3:  GOTO   60F
....................                    
....................                   if (k == '*' || k == '#'){ 
05F4:  MOVF   32,W
05F5:  SUBLW  2A
05F6:  BTFSC  03.2
05F7:  GOTO   5FC
05F8:  MOVF   32,W
05F9:  SUBLW  23
05FA:  BTFSS  03.2
05FB:  GOTO   5FE
....................                      k='\0'; 
05FC:  CLRF   32
....................                   } 
....................                    
....................                   else{ 
05FD:  GOTO   60F
....................                      LCD_GOTOXY(DIR,2); 
05FE:  MOVF   30,W
05FF:  MOVWF  48
0600:  MOVLW  02
0601:  MOVWF  49
0602:  CALL   0C9
....................                      lcd_putc(k); 
0603:  MOVF   32,W
0604:  MOVWF  47
0605:  CALL   0DB
....................                      aux [i]= k;//guardando los datos de teclado en variable auxiliar 
0606:  MOVLW  33
0607:  ADDWF  35,W
0608:  MOVWF  04
0609:  BCF    03.7
060A:  MOVF   32,W
060B:  MOVWF  00
....................                      i++;//incrementador del puntero de la variable auxiliar 
060C:  INCF   35,F
....................                      k='\0'; 
060D:  CLRF   32
....................                      DIR++; 
060E:  INCF   30,F
....................                       
....................                   } 
....................                    
....................                } 
....................             }else if(k=='#'){ 
060F:  GOTO   617
0610:  MOVF   32,W
0611:  SUBLW  23
0612:  BTFSS  03.2
0613:  GOTO   617
....................                      k='\0'; 
0614:  CLRF   32
....................                      DIR = 17; 
0615:  MOVLW  11
0616:  MOVWF  30
....................                   } 
....................          
....................           
....................  // ============================================================================= //         
....................          
....................          k=tecla_time();   //Lee el valor del teclado pero solo espera un tiempo determinado 
0617:  GOTO   1B6
0618:  MOVF   78,W
0619:  MOVWF  32
....................           
....................   // ============================================================================= //    
....................          if(DIR>16) 
061A:  MOVF   30,W
061B:  SUBLW  10
061C:  BTFSC  03.0
061D:  GOTO   625
....................             LCD_PUTC("\f"); 
061E:  MOVLW  2B
061F:  BSF    03.6
0620:  MOVWF  0D
0621:  MOVLW  00
0622:  MOVWF  0F
0623:  BCF    03.6
0624:  CALL   100
....................           
....................        //Lectura ADC 
....................         set_adc_channel(0);          //Selecciono el canal 0 (RA0) 
0625:  MOVLW  00
0626:  MOVWF  78
0627:  MOVF   1F,W
0628:  ANDLW  C3
0629:  IORWF  78,W
062A:  MOVWF  1F
....................         delay_ms(1);                 //llamo retardo de 1 ms 
062B:  MOVLW  01
062C:  MOVWF  48
062D:  CALL   034
....................         bits=read_adc();             //Guarde el dato del LM en tempe 
062E:  BSF    1F.1
062F:  BTFSC  1F.1
0630:  GOTO   62F
0631:  BSF    03.5
0632:  MOVF   1E,W
0633:  BCF    03.5
0634:  MOVWF  2A
0635:  MOVF   1E,W
0636:  MOVWF  2B
....................         tem=bits*0.0488758553;              //Conversion de bits a temperatura 
0637:  MOVF   2B,W
0638:  MOVWF  3B
0639:  MOVF   2A,W
063A:  MOVWF  3A
063B:  GOTO   1D9
063C:  MOVF   7A,W
063D:  MOVWF  4A
063E:  MOVF   79,W
063F:  MOVWF  49
0640:  MOVF   78,W
0641:  MOVWF  48
0642:  MOVF   77,W
0643:  MOVWF  47
0644:  MOVLW  0D
0645:  MOVWF  4E
0646:  MOVLW  32
0647:  MOVWF  4D
0648:  MOVLW  48
0649:  MOVWF  4C
064A:  MOVLW  7A
064B:  MOVWF  4B
064C:  CALL   1F8
064D:  MOVF   7A,W
064E:  MOVWF  2F
064F:  MOVF   79,W
0650:  MOVWF  2E
0651:  MOVF   78,W
0652:  MOVWF  2D
0653:  MOVF   77,W
0654:  MOVWF  2C
....................         lcd_gotoxy(1,1);             //Ubiquese en la posicion 2,2 
0655:  MOVLW  01
0656:  MOVWF  48
0657:  MOVWF  49
0658:  CALL   0C9
....................         printf(lcd_putc,"Temp. R= %f    ",tem);  //Muestra el valor numerico de la conversion 
0659:  MOVLW  2C
065A:  BSF    03.6
065B:  MOVWF  0D
065C:  MOVLW  00
065D:  MOVWF  0F
065E:  BCF    03.0
065F:  MOVLW  09
0660:  BCF    03.6
0661:  MOVWF  3A
0662:  CALL   26D
0663:  MOVLW  89
0664:  MOVWF  04
0665:  MOVF   2F,W
0666:  MOVWF  3D
0667:  MOVF   2E,W
0668:  MOVWF  3C
0669:  MOVF   2D,W
066A:  MOVWF  3B
066B:  MOVF   2C,W
066C:  MOVWF  3A
066D:  MOVLW  02
066E:  MOVWF  3E
066F:  GOTO   2FD
0670:  MOVLW  31
0671:  BSF    03.6
0672:  MOVWF  0D
0673:  MOVLW  00
0674:  MOVWF  0F
0675:  BSF    03.0
0676:  MOVLW  04
0677:  BCF    03.6
0678:  MOVWF  3A
0679:  CALL   26D
....................          
....................          
....................              //Codigo del ventilador 
....................         float comp = atol(aux); 
067A:  CLRF   3B
067B:  MOVLW  33
067C:  MOVWF  3A
067D:  GOTO   3E6
067E:  MOVF   79,W
067F:  MOVWF  3B
0680:  MOVF   78,W
0681:  MOVWF  3A
0682:  GOTO   51C
0683:  MOVF   7A,W
0684:  MOVWF  39
0685:  MOVF   79,W
0686:  MOVWF  38
0687:  MOVF   78,W
0688:  MOVWF  37
0689:  MOVF   77,W
068A:  MOVWF  36
....................          if(tem >= comp){                       // comparacion de la temperatura real a la temperatura ajustada  
068B:  MOVF   39,W
068C:  MOVWF  3D
068D:  MOVF   38,W
068E:  MOVWF  3C
068F:  MOVF   37,W
0690:  MOVWF  3B
0691:  MOVF   36,W
0692:  MOVWF  3A
0693:  MOVF   2F,W
0694:  MOVWF  41
0695:  MOVF   2E,W
0696:  MOVWF  40
0697:  MOVF   2D,W
0698:  MOVWF  3F
0699:  MOVF   2C,W
069A:  MOVWF  3E
069B:  GOTO   543
069C:  BTFSC  03.0
069D:  GOTO   6A0
069E:  BTFSS  03.2
069F:  GOTO   6A5
....................             output_high(pin_a2);//encendera ventelidar en caso de sobre pasar la ajustada 
06A0:  BSF    03.5
06A1:  BCF    05.2
06A2:  BCF    03.5
06A3:  BSF    05.2
....................              
....................          }else{ 
06A4:  GOTO   6A9
....................             output_low(pin_a2);//de lo contrario la apagara 
06A5:  BSF    03.5
06A6:  BCF    05.2
06A7:  BCF    03.5
06A8:  BCF    05.2
....................              
....................          } 
....................       } 
06A9:  GOTO   5E9
....................        
....................    } 
06AA:  GOTO   5C5
.................... } 
06AB:  SLEEP

Configuration Fuses:
   Word  1: 2CF1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
