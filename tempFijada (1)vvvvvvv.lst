CCS PCM C Compiler, Version 4.104, 5967               22-dic-19 10:25

               Filename: C:\Users\PILAR\Desktop\ProyectoPICfuncional\tempFijada (1)vvvvvvv.lst

               ROM used: 1806 words (22%)
                         Largest free fragment is 2048
               RAM used: 28 (8%) at main() level
                         59 (16%) worst case
               Stack:    5 locations

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5A1
0003:  NOP
.................... #INCLUDE <16F887.H> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
.................... #device adc=10 
.................... #USE DELAY(CLOCK=4000000) 
*
0034:  MOVLW  4A
0035:  MOVWF  04
0036:  BCF    03.7
0037:  MOVF   00,W
0038:  BTFSC  03.2
0039:  GOTO   048
003A:  MOVLW  01
003B:  MOVWF  78
003C:  CLRF   77
003D:  DECFSZ 77,F
003E:  GOTO   03D
003F:  DECFSZ 78,F
0040:  GOTO   03C
0041:  MOVLW  4A
0042:  MOVWF  77
0043:  DECFSZ 77,F
0044:  GOTO   043
0045:  GOTO   046
0046:  DECFSZ 00,F
0047:  GOTO   03A
0048:  RETURN
.................... #FUSES XT,NOPROTECT,NOWDT,NOBROWNOUT,NOPUT,NOLVP 
.................... //#DEFINE USE_PORTB_LCD TRUE 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7)   // Pines para establecer comunicacion rs232 
.................... #DEFINE USE_PORTB_KBD   //Por defecto el teclado se conecta al puerto D, 
....................                         //como el microcontrolador que se esta usando 
....................                         //no tiene puerto D se conecta al puerto B. 
....................    
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
05BF:  BCF    03.6
05C0:  CLRF   20
05C1:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03E6:  CLRF   42
....................    sign = 0; 
03E7:  CLRF   40
....................    base = 10; 
03E8:  MOVLW  0A
03E9:  MOVWF  41
....................    result = 0; 
03EA:  CLRF   3F
03EB:  CLRF   3E
....................  
....................    if (!s) 
03EC:  MOVF   3C,W
03ED:  IORWF  3D,W
03EE:  BTFSS  03.2
03EF:  GOTO   3F4
....................       return 0; 
03F0:  MOVLW  00
03F1:  MOVWF  78
03F2:  MOVWF  79
03F3:  GOTO   519
....................    c = s[index++]; 
03F4:  MOVF   42,W
03F5:  INCF   42,F
03F6:  ADDWF  3C,W
03F7:  MOVWF  04
03F8:  BCF    03.7
03F9:  BTFSC  3D.0
03FA:  BSF    03.7
03FB:  MOVF   00,W
03FC:  MOVWF  43
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03FD:  MOVF   43,W
03FE:  SUBLW  2D
03FF:  BTFSS  03.2
0400:  GOTO   40D
....................    { 
....................       sign = 1;         // Set the sign to negative 
0401:  MOVLW  01
0402:  MOVWF  40
....................       c = s[index++]; 
0403:  MOVF   42,W
0404:  INCF   42,F
0405:  ADDWF  3C,W
0406:  MOVWF  04
0407:  BCF    03.7
0408:  BTFSC  3D.0
0409:  BSF    03.7
040A:  MOVF   00,W
040B:  MOVWF  43
....................    } 
....................    else if (c == '+') 
040C:  GOTO   41A
040D:  MOVF   43,W
040E:  SUBLW  2B
040F:  BTFSS  03.2
0410:  GOTO   41A
....................    { 
....................       c = s[index++]; 
0411:  MOVF   42,W
0412:  INCF   42,F
0413:  ADDWF  3C,W
0414:  MOVWF  04
0415:  BCF    03.7
0416:  BTFSC  3D.0
0417:  BSF    03.7
0418:  MOVF   00,W
0419:  MOVWF  43
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
041A:  MOVF   43,W
041B:  SUBLW  2F
041C:  BTFSC  03.0
041D:  GOTO   50A
041E:  MOVF   43,W
041F:  SUBLW  39
0420:  BTFSS  03.0
0421:  GOTO   50A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0422:  MOVF   43,W
0423:  SUBLW  30
0424:  BTFSS  03.2
0425:  GOTO   446
0426:  MOVF   42,W
0427:  ADDWF  3C,W
0428:  MOVWF  04
0429:  BCF    03.7
042A:  BTFSC  3D.0
042B:  BSF    03.7
042C:  MOVF   00,W
042D:  SUBLW  78
042E:  BTFSC  03.2
042F:  GOTO   43A
0430:  MOVF   42,W
0431:  ADDWF  3C,W
0432:  MOVWF  04
0433:  BCF    03.7
0434:  BTFSC  3D.0
0435:  BSF    03.7
0436:  MOVF   00,W
0437:  SUBLW  58
0438:  BTFSS  03.2
0439:  GOTO   446
....................       { 
....................          base = 16; 
043A:  MOVLW  10
043B:  MOVWF  41
....................          index++; 
043C:  INCF   42,F
....................          c = s[index++]; 
043D:  MOVF   42,W
043E:  INCF   42,F
043F:  ADDWF  3C,W
0440:  MOVWF  04
0441:  BCF    03.7
0442:  BTFSC  3D.0
0443:  BSF    03.7
0444:  MOVF   00,W
0445:  MOVWF  43
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0446:  MOVF   41,W
0447:  SUBLW  0A
0448:  BTFSS  03.2
0449:  GOTO   499
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
044A:  MOVF   43,W
044B:  SUBLW  2F
044C:  BTFSC  03.0
044D:  GOTO   498
044E:  MOVF   43,W
044F:  SUBLW  39
0450:  BTFSS  03.0
0451:  GOTO   498
....................             result = 10*result + (c - '0'); 
0452:  CLRF   45
0453:  MOVLW  0A
0454:  MOVWF  44
0455:  MOVF   3F,W
0456:  MOVWF  47
0457:  MOVF   3E,W
0458:  MOVWF  46
*
0486:  MOVLW  30
0487:  SUBWF  43,W
0488:  ADDWF  78,W
0489:  MOVWF  3E
048A:  MOVF   79,W
048B:  MOVWF  3F
048C:  BTFSC  03.0
048D:  INCF   3F,F
....................             c = s[index++]; 
048E:  MOVF   42,W
048F:  INCF   42,F
0490:  ADDWF  3C,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  3D.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  MOVWF  43
....................          } 
0497:  GOTO   44A
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0498:  GOTO   50A
0499:  MOVF   41,W
049A:  SUBLW  10
049B:  BTFSS  03.2
049C:  GOTO   50A
....................       { 
....................          c = toupper(c); 
049D:  MOVF   43,W
049E:  SUBLW  60
049F:  BTFSC  03.0
04A0:  GOTO   4A8
04A1:  MOVF   43,W
04A2:  SUBLW  7A
04A3:  BTFSS  03.0
04A4:  GOTO   4A8
04A5:  MOVF   43,W
04A6:  ANDLW  DF
04A7:  GOTO   4A9
04A8:  MOVF   43,W
04A9:  MOVWF  43
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
04AA:  MOVF   43,W
04AB:  SUBLW  2F
04AC:  BTFSC  03.0
04AD:  GOTO   4B2
04AE:  MOVF   43,W
04AF:  SUBLW  39
04B0:  BTFSC  03.0
04B1:  GOTO   4BA
04B2:  MOVF   43,W
04B3:  SUBLW  40
04B4:  BTFSC  03.0
04B5:  GOTO   50A
04B6:  MOVF   43,W
04B7:  SUBLW  46
04B8:  BTFSS  03.0
04B9:  GOTO   50A
....................             if (c >= '0' && c <= '9') 
04BA:  MOVF   43,W
04BB:  SUBLW  2F
04BC:  BTFSC  03.0
04BD:  GOTO   4DB
04BE:  MOVF   43,W
04BF:  SUBLW  39
04C0:  BTFSS  03.0
04C1:  GOTO   4DB
....................                result = (result << 4) + (c - '0'); 
04C2:  RLF    3E,W
04C3:  MOVWF  44
04C4:  RLF    3F,W
04C5:  MOVWF  45
04C6:  RLF    44,F
04C7:  RLF    45,F
04C8:  RLF    44,F
04C9:  RLF    45,F
04CA:  RLF    44,F
04CB:  RLF    45,F
04CC:  MOVLW  F0
04CD:  ANDWF  44,F
04CE:  MOVLW  30
04CF:  SUBWF  43,W
04D0:  ADDWF  44,W
04D1:  MOVWF  78
04D2:  MOVF   45,W
04D3:  MOVWF  7A
04D4:  BTFSC  03.0
04D5:  INCF   7A,F
04D6:  MOVF   78,W
04D7:  MOVWF  3E
04D8:  MOVF   7A,W
04D9:  MOVWF  3F
....................             else 
04DA:  GOTO   4F4
....................                result = (result << 4) + (c - 'A' + 10); 
04DB:  RLF    3E,W
04DC:  MOVWF  44
04DD:  RLF    3F,W
04DE:  MOVWF  45
04DF:  RLF    44,F
04E0:  RLF    45,F
04E1:  RLF    44,F
04E2:  RLF    45,F
04E3:  RLF    44,F
04E4:  RLF    45,F
04E5:  MOVLW  F0
04E6:  ANDWF  44,F
04E7:  MOVLW  41
04E8:  SUBWF  43,W
04E9:  ADDLW  0A
04EA:  ADDWF  44,W
04EB:  MOVWF  78
04EC:  MOVF   45,W
04ED:  MOVWF  7A
04EE:  BTFSC  03.0
04EF:  INCF   7A,F
04F0:  MOVF   78,W
04F1:  MOVWF  3E
04F2:  MOVF   7A,W
04F3:  MOVWF  3F
....................  
....................             c = s[index++];c = toupper(c); 
04F4:  MOVF   42,W
04F5:  INCF   42,F
04F6:  ADDWF  3C,W
04F7:  MOVWF  04
04F8:  BCF    03.7
04F9:  BTFSC  3D.0
04FA:  BSF    03.7
04FB:  MOVF   00,W
04FC:  MOVWF  43
04FD:  SUBLW  60
04FE:  BTFSC  03.0
04FF:  GOTO   507
0500:  MOVF   43,W
0501:  SUBLW  7A
0502:  BTFSS  03.0
0503:  GOTO   507
0504:  MOVF   43,W
0505:  ANDLW  DF
0506:  GOTO   508
0507:  MOVF   43,W
0508:  MOVWF  43
....................          } 
0509:  GOTO   4AA
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
050A:  MOVF   41,W
050B:  SUBLW  0A
050C:  BTFSS  03.2
050D:  GOTO   515
050E:  DECFSZ 40,W
050F:  GOTO   515
....................       result = -result; 
0510:  COMF   3E,F
0511:  COMF   3F,F
0512:  INCF   3E,F
0513:  BTFSC  03.2
0514:  INCF   3F,F
....................  
....................    return(result); 
0515:  MOVF   3E,W
0516:  MOVWF  78
0517:  MOVF   3F,W
0518:  MOVWF  79
.................... } 
0519:  BCF    0A.3
051A:  BCF    0A.4
051B:  GOTO   69A (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
005C:  MOVLW  0F
005D:  BSF    03.5
005E:  ANDWF  08,W
005F:  IORLW  F0
0060:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0061:  BCF    03.5
0062:  BSF    08.2
....................    delay_cycles(1); 
0063:  NOP
....................    lcd_output_enable(1); 
0064:  BSF    08.0
....................    delay_cycles(1); 
0065:  NOP
....................    high = lcd_read_nibble(); 
0066:  CALL   055
0067:  MOVF   78,W
0068:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
0069:  BCF    08.0
....................    delay_cycles(1); 
006A:  NOP
....................    lcd_output_enable(1); 
006B:  BSF    08.0
....................    delay_us(1); 
006C:  NOP
....................    low = lcd_read_nibble(); 
006D:  CALL   055
006E:  MOVF   78,W
006F:  MOVWF  50
....................        
....................    lcd_output_enable(0); 
0070:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0071:  MOVLW  0F
0072:  BSF    03.5
0073:  ANDWF  08,W
0074:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0075:  BCF    03.5
0076:  SWAPF  51,W
0077:  MOVWF  77
0078:  MOVLW  F0
0079:  ANDWF  77,F
007A:  MOVF   77,W
007B:  IORWF  50,W
007C:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0055:  MOVF   08,W
0056:  MOVWF  77
0057:  SWAPF  08,W
0058:  ANDLW  0F
0059:  MOVWF  78
....................   #endif 
.................... } 
005A:  RETURN
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0049:  SWAPF  51,W
004A:  ANDLW  F0
004B:  MOVWF  77
004C:  MOVLW  0F
004D:  ANDWF  08,W
004E:  IORWF  77,W
004F:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0050:  NOP
....................    lcd_output_enable(1); 
0051:  BSF    08.0
....................    delay_us(2); 
0052:  GOTO   053
....................    lcd_output_enable(0); 
0053:  BCF    08.0
.................... } 
0054:  RETURN
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
*
005B:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
007D:  MOVF   78,W
007E:  MOVWF  50
007F:  BTFSC  50.7
0080:  GOTO   05C
....................    lcd_output_rs(address); 
0081:  BTFSS  4E.0
0082:  BCF    08.1
0083:  BTFSC  4E.0
0084:  BSF    08.1
....................    delay_cycles(1); 
0085:  NOP
....................    lcd_output_rw(0); 
0086:  BCF    08.2
....................    delay_cycles(1); 
0087:  NOP
....................    lcd_output_enable(0); 
0088:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0089:  SWAPF  4F,W
008A:  MOVWF  50
008B:  MOVLW  0F
008C:  ANDWF  50,F
008D:  MOVF   50,W
008E:  MOVWF  51
008F:  CALL   049
....................    lcd_send_nibble(n & 0xf); 
0090:  MOVF   4F,W
0091:  ANDLW  0F
0092:  MOVWF  50
0093:  MOVWF  51
0094:  CALL   049
.................... } 
0095:  RETURN
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0096:  MOVLW  0F
0097:  BSF    03.5
0098:  ANDWF  08,W
0099:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
009A:  BCF    08.0
....................    lcd_rs_tris(); 
009B:  BCF    08.1
....................    lcd_rw_tris(); 
009C:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
009D:  BCF    03.5
009E:  BCF    08.1
....................    lcd_output_rw(0); 
009F:  BCF    08.2
....................    lcd_output_enable(0); 
00A0:  BCF    08.0
....................      
....................    delay_ms(15); 
00A1:  MOVLW  0F
00A2:  MOVWF  4A
00A3:  CALL   034
....................    for(i=1;i<=3;++i) 
00A4:  MOVLW  01
00A5:  MOVWF  3C
00A6:  MOVF   3C,W
00A7:  SUBLW  03
00A8:  BTFSS  03.0
00A9:  GOTO   0B2
....................    { 
....................        lcd_send_nibble(3); 
00AA:  MOVLW  03
00AB:  MOVWF  51
00AC:  CALL   049
....................        delay_ms(5); 
00AD:  MOVLW  05
00AE:  MOVWF  4A
00AF:  CALL   034
....................    } 
00B0:  INCF   3C,F
00B1:  GOTO   0A6
....................      
....................    lcd_send_nibble(2); 
00B2:  MOVLW  02
00B3:  MOVWF  51
00B4:  CALL   049
....................    for(i=0;i<=3;++i) 
00B5:  CLRF   3C
00B6:  MOVF   3C,W
00B7:  SUBLW  03
00B8:  BTFSS  03.0
00B9:  GOTO   0C3
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00BA:  MOVF   3C,W
00BB:  CALL   004
00BC:  MOVWF  3D
00BD:  CLRF   4E
00BE:  MOVF   3D,W
00BF:  MOVWF  4F
00C0:  CALL   05B
00C1:  INCF   3C,F
00C2:  GOTO   0B6
.................... } 
00C3:  BCF    0A.3
00C4:  BCF    0A.4
00C5:  GOTO   5DA (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
00C9:  DECFSZ 4B,W
00CA:  GOTO   0CC
00CB:  GOTO   0CF
....................       address=LCD_LINE_TWO; 
00CC:  MOVLW  40
00CD:  MOVWF  4C
....................    else 
00CE:  GOTO   0D0
....................       address=0; 
00CF:  CLRF   4C
....................       
....................    address+=x-1; 
00D0:  MOVLW  01
00D1:  SUBWF  4A,W
00D2:  ADDWF  4C,F
....................    lcd_send_byte(0,0x80|address); 
00D3:  MOVF   4C,W
00D4:  IORLW  80
00D5:  MOVWF  4D
00D6:  CLRF   4E
00D7:  MOVF   4D,W
00D8:  MOVWF  4F
00D9:  CALL   05B
.................... } 
00DA:  RETURN
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
00DB:  MOVF   49,W
00DC:  XORLW  0C
00DD:  BTFSC  03.2
00DE:  GOTO   0E6
00DF:  XORLW  06
00E0:  BTFSC  03.2
00E1:  GOTO   0EE
00E2:  XORLW  02
00E3:  BTFSC  03.2
00E4:  GOTO   0F4
00E5:  GOTO   0F9
....................       case '\f'   :  lcd_send_byte(0,1); 
00E6:  CLRF   4E
00E7:  MOVLW  01
00E8:  MOVWF  4F
00E9:  CALL   05B
....................                      delay_ms(2); 
00EA:  MOVLW  02
00EB:  MOVWF  4A
00EC:  CALL   034
....................                      break; 
00ED:  GOTO   0FF
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EE:  MOVLW  01
00EF:  MOVWF  4A
00F0:  MOVLW  02
00F1:  MOVWF  4B
00F2:  CALL   0C9
00F3:  GOTO   0FF
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00F4:  CLRF   4E
00F5:  MOVLW  10
00F6:  MOVWF  4F
00F7:  CALL   05B
00F8:  GOTO   0FF
....................       
....................       default     : lcd_send_byte(1,c);     break; 
00F9:  MOVLW  01
00FA:  MOVWF  4E
00FB:  MOVF   49,W
00FC:  MOVWF  4F
00FD:  CALL   05B
00FE:  GOTO   0FF
....................    } 
.................... } 
00FF:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #INCLUDE <KBD4x4.C>  //Incluir en el encabezado el driver para 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
.................... //// KBD4x4_1.C //// 
.................... //// Controlador de escaneo de teclado genrico //// 
.................... //// //// 
.................... //// kbd_init () Debe llamarse antes que cualquier otra funcin. //// 
.................... //// //// 
.................... //// c = kbd_getc (c) Devuelve un valor clave si se presiona o / 0 si no //// 
.................... //// Esta funcin debe llamarse con frecuencia para //// 
.................... //// para no perder una pulsacin de tecla. //// 
.................... //// //// 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
.................... //// (C) Copyright 1996,2003 Servicios informticos personalizados //// 
.................... //// Este cdigo fuente solo puede ser utilizado por usuarios con licencia de CCS C //// 
.................... //// compilador. Este cdigo fuente solo se puede distribuir a otros //// 
.................... //// usuarios con licencia del compilador CCS C. Ningn otro uso, reproduccin //// 
.................... //// o la distribucin est permitida sin un permiso por escrito. //// 
.................... //// Programas derivados creados con este software en cdigo objeto //// 
.................... //// forma no estn restringidos de ninguna manera. //// 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////// ////////////////////////// 
....................  
.................... ////////////////// Lo siguiente define el diseo del teclado en el puerto D 
....................  
.................... // Descomenta la siguiente definicin para usar el puerto B 
.................... // #define use_portb_kbd VERDADERO 
....................  
.................... // Asegrese de que el puerto utilizado tenga resistencias pull-up (o la pantalla LCD) en 
.................... // los pines de columna 
....................  
....................  
.................... #if defined (__PH__) 
.................... #if defined use_portb_kbd  
....................    #byte kbd = 0xF81 // Esto pone toda la estructura 
.................... #else 
....................    #byte kbd = 0xF83 // Esto pone toda la estructura 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd  
....................    #byte kbd = 6 // en el puerto B (en la direccin 6) 
.................... #else 
....................    #byte kbd = 8 // en el puerto D (en la direccin 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd  
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif  
....................  
....................  
....................  
.................... // Conexin del teclado: (por ejemplo, la columna 0 es B2) 
.................... // Bx: 
....................  
.................... #ifdef blue_keypad ///////////////////////////////////// Para el teclado azul 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// // Para el teclado negro 
.................... #define COL0 (1 << 4) 
.................... #define COL1 (1 << 5) 
.................... #define COL2 (1 << 6) 
.................... #define COL3 (1 << 7) 
....................  
.................... #define ROW0 (1 << 0) 
.................... #define ROW1 (1 << 1) 
.................... #define ROW2 (1 << 2) 
.................... #define ROW3 (1 << 3) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2|COL3) 
....................  
.................... // Diseo del teclado: 
.................... char const KEYS[4][4] = {{'1', '2', '3', 'A'}, 
....................                          {'4', '5', '6', 'B'}, 
....................                          {'7', '8', '9', 'C'}, 
....................                          {'*', '0', '#', 'D'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33 // Establezca este nmero en apx n / 333 donde 
....................                                   // n es el nmero de veces que espera 
....................                                   // para llamar a kbd_getc cada segundo 
....................  
....................  
.................... void kbd_init () { 
.................... } 
*
00C6:  BCF    0A.3
00C7:  BCF    0A.4
00C8:  GOTO   5DB (RETURN)
....................  
.................... char kbd_getc () { 
....................    static BYTE kbd_call_count;   
*
05C2:  CLRF   26
....................    static short int kbd_down; 
05C3:  BCF    27.0
....................    static char last_key; 
05C4:  CLRF   28
....................    static BYTE col; 
05C5:  CLRF   29
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0146:  CLRF   3F
....................    if (++kbd_call_count > KBD_DEBOUNCE_FACTOR) { 
0147:  INCF   26,F
0148:  MOVF   26,W
0149:  SUBLW  21
014A:  BTFSC  03.0
014B:  GOTO   1A7
....................        switch (col) { 
014C:  MOVF   29,W
014D:  ADDLW  FC
014E:  BTFSC  03.0
014F:  GOTO   16A
0150:  ADDLW  04
0151:  GOTO   1AE
....................          case 0: set_tris_kbd(ALL_PINS&~COL0); 
0152:  MOVLW  EF
0153:  BSF    03.5
0154:  MOVWF  06
....................                     kbd = ~COL0&ALL_PINS; 
0155:  BCF    03.5
0156:  MOVWF  06
....................                     break; 
0157:  GOTO   16A
....................          case 1: set_tris_kbd (ALL_PINS & ~ COL1); 
0158:  MOVLW  DF
0159:  BSF    03.5
015A:  MOVWF  06
....................                     kbd = ~ COL1 & ALL_PINS; 
015B:  BCF    03.5
015C:  MOVWF  06
....................                     break; 
015D:  GOTO   16A
....................          case 2: set_tris_kbd (ALL_PINS & ~ COL2); 
015E:  MOVLW  BF
015F:  BSF    03.5
0160:  MOVWF  06
....................                     kbd = ~ COL2 & ALL_PINS; 
0161:  BCF    03.5
0162:  MOVWF  06
....................                     break; 
0163:  GOTO   16A
....................          case 3: set_tris_kbd (ALL_PINS & ~ COL3); 
0164:  MOVLW  7F
0165:  BSF    03.5
0166:  MOVWF  06
....................                     kbd = ~ COL3 & ALL_PINS; 
0167:  BCF    03.5
0168:  MOVWF  06
....................                     break; 
0169:  GOTO   16A
....................        } 
....................  
....................        if (kbd_down) { 
016A:  BTFSS  27.0
016B:  GOTO   176
....................          if ((kbd & (ALL_ROWS)) == (ALL_ROWS)) { 
016C:  MOVF   06,W
016D:  ANDLW  0F
016E:  SUBLW  0F
016F:  BTFSS  03.2
0170:  GOTO   175
....................            kbd_down = FALSE; 
0171:  BCF    27.0
....................            kchar = last_key; 
0172:  MOVF   28,W
0173:  MOVWF  3F
....................            last_key = '\0'; 
0174:  CLRF   28
....................          } 
....................        } else { 
0175:  GOTO   1A6
....................           if ((kbd & (ALL_ROWS)) != (ALL_ROWS)) { 
0176:  MOVF   06,W
0177:  ANDLW  0F
0178:  SUBLW  0F
0179:  BTFSC  03.2
017A:  GOTO   1A1
....................              if ((kbd & ROW0) == 0) 
017B:  MOVF   06,W
017C:  ANDLW  01
017D:  BTFSS  03.2
017E:  GOTO   181
....................                row = 0; 
017F:  CLRF   40
....................              else if ((kbd & ROW1) == 0) 
0180:  GOTO   195
0181:  MOVF   06,W
0182:  ANDLW  02
0183:  BTFSS  03.2
0184:  GOTO   188
....................                row = 1; 
0185:  MOVLW  01
0186:  MOVWF  40
....................              else if ((kbd & ROW2) == 0) 
0187:  GOTO   195
0188:  MOVF   06,W
0189:  ANDLW  04
018A:  BTFSS  03.2
018B:  GOTO   18F
....................                row = 2; 
018C:  MOVLW  02
018D:  MOVWF  40
....................              else if ((kbd & ROW3) == 0) 
018E:  GOTO   195
018F:  MOVF   06,W
0190:  ANDLW  08
0191:  BTFSS  03.2
0192:  GOTO   195
....................                row = 3; 
0193:  MOVLW  03
0194:  MOVWF  40
....................              last_key = KEYS [row] [col]; 
0195:  RLF    40,W
0196:  MOVWF  77
0197:  RLF    77,F
0198:  MOVLW  FC
0199:  ANDWF  77,F
019A:  MOVF   77,W
019B:  ADDWF  29,W
019C:  CALL   00C
019D:  MOVWF  78
019E:  MOVWF  28
....................              kbd_down = TRUE; 
019F:  BSF    27.0
....................           } else { 
01A0:  GOTO   1A6
....................              ++ col; 
01A1:  INCF   29,F
....................              if (col == 4) 
01A2:  MOVF   29,W
01A3:  SUBLW  04
01A4:  BTFSC  03.2
....................                col = 0; 
01A5:  CLRF   29
....................           } 
....................        } 
....................       kbd_call_count = 0; 
01A6:  CLRF   26
....................    } 
....................   set_tris_kbd (ALL_PINS); 
01A7:  MOVLW  FF
01A8:  BSF    03.5
01A9:  MOVWF  06
....................   return (kchar); 
01AA:  BCF    03.5
01AB:  MOVF   3F,W
01AC:  MOVWF  78
.................... } 
01AD:  RETURN
....................  
....................                       //manejar el teclado telefnico MODIFICADO 
.................... #use     standard_io(b)  
.................... #define  KEYHIT_DELAY   200    //Tiempo de espera del teclado en milisegundos 
.................... #byte PORTB= 6 
.................... #byte PORTC= 7 
.................... #BYTE PORTA= 5 
.................... #BYTE PORTD= 8 
.................... #define motor pin_a2 
.................... #define foco pin_a3 
....................   
.................... long bits;     //Variable almacena los bits 
.................... float tem;     //Almacena la temperatura 
....................  
....................  
....................   INT DIR; 
....................  
.................... /*===========================================================================*/ 
.................... /*=======================       FUNCION TECLA         =======================*/ 
.................... /*===========================================================================*/ 
.................... //Funcion encargada de esperar a que se presione una tecla  
.................... char tecla(void){ 
....................    char c; 
....................    do{ //espera hasta que se presione una tecla 
....................       c=kbd_getc(); //Captura valor del teclado 
....................      } 
....................    while(c=='\0'); 
....................    return(c); 
.................... } 
....................  
.................... /*===========================================================================*/ 
.................... /*=======================    FUNCION TECLA CON TIMER  =======================*/ 
.................... /*===========================================================================*/ 
.................... // Pregunta por una Tecla por un tiempo, si no hay actividad, deja de preguntar 
.................... // y deja que el PIC continue con su trabajo 
....................  
.................... char tecla_time(void) { 
*
01B6:  CLRF   3C
....................    char c='\0'; 
....................    unsigned int16 timeout; 
....................    timeout=0; 
01B7:  CLRF   3E
01B8:  CLRF   3D
....................    c=kbd_getc(); //Captura valor del teclado 
01B9:  CALL   146
01BA:  MOVF   78,W
01BB:  MOVWF  3C
....................    while(c=='\0' && (++timeout< (KEYHIT_DELAY*100))) 
....................    { 
01BC:  MOVF   3C,F
01BD:  BTFSS  03.2
01BE:  GOTO   1D4
01BF:  INCF   3D,F
01C0:  BTFSC  03.2
01C1:  INCF   3E,F
01C2:  MOVF   3E,W
01C3:  SUBLW  4E
01C4:  BTFSS  03.0
01C5:  GOTO   1D4
01C6:  BTFSS  03.2
01C7:  GOTO   1CC
01C8:  MOVF   3D,W
01C9:  SUBLW  1F
01CA:  BTFSS  03.0
01CB:  GOTO   1D4
....................       delay_us(10); 
01CC:  MOVLW  03
01CD:  MOVWF  77
01CE:  DECFSZ 77,F
01CF:  GOTO   1CE
....................       c=kbd_getc(); //Captura valor del teclado 
01D0:  CALL   146
01D1:  MOVF   78,W
01D2:  MOVWF  3C
....................    } 
01D3:  GOTO   1BC
....................    return(c); 
01D4:  MOVF   3C,W
01D5:  MOVWF  78
.................... } 
01D6:  BCF    0A.3
01D7:  BCF    0A.4
01D8:  GOTO   635 (RETURN)
....................  
.................... /*===========================================================================*/ 
.................... /*=======================       PROGRAMA PRINCIPAL    =======================*/ 
.................... /*===========================================================================*/ 
....................  
.................... VOID MAIN() 
.................... { 
*
05A1:  CLRF   04
05A2:  BCF    03.7
05A3:  MOVLW  1F
05A4:  ANDWF  03,F
05A5:  BSF    03.5
05A6:  BSF    03.6
05A7:  BCF    07.3
05A8:  MOVLW  19
05A9:  BCF    03.6
05AA:  MOVWF  19
05AB:  MOVLW  A6
05AC:  MOVWF  18
05AD:  MOVLW  90
05AE:  BCF    03.5
05AF:  MOVWF  18
05B0:  BSF    03.5
05B1:  BSF    03.6
05B2:  MOVF   09,W
05B3:  ANDLW  C0
05B4:  MOVWF  09
05B5:  BCF    03.6
05B6:  BCF    1F.4
05B7:  BCF    1F.5
05B8:  MOVLW  00
05B9:  BSF    03.6
05BA:  MOVWF  08
05BB:  BCF    03.5
05BC:  CLRF   07
05BD:  CLRF   08
05BE:  CLRF   09
....................   CHAR K; 
....................    
....................    char aux[2];//declaramos una variable auxiliar para guardar datos del teclado 
....................     
....................    port_b_pullups (0xFF);  //Utiliza las resistencias PULL UP internas del puerto B 
*
05C8:  MOVLW  FF
05C9:  BSF    03.5
05CA:  MOVWF  15
05CB:  BCF    01.7
....................     
....................    set_tris_a(0b00000001);          //Pongo el RA0 como entrada 
05CC:  MOVLW  01
05CD:  MOVWF  05
....................    SET_TRIS_B(1); 
05CE:  MOVWF  06
....................    SET_TRIS_C(0);    //Puerto C como Salida 
05CF:  MOVLW  00
05D0:  MOVWF  07
05D1:  BCF    03.5
05D2:  MOVWF  31
....................     
....................    setup_adc(adc_clock_internal);   //Selecciono reloj interno para conversion 
05D3:  BSF    1F.6
05D4:  BSF    1F.7
05D5:  BSF    03.5
05D6:  BSF    1F.7
05D7:  BCF    03.5
05D8:  BSF    1F.0
....................     
....................    LCD_INIT();       //Inicializar el driver del lcd 
05D9:  GOTO   096
....................    KBD_INIT();       //Inicializar el driver del teclado 
05DA:  GOTO   0C6
....................    LCD_PUTC("\f");   //Limpia el LCD 
05DB:  MOVLW  25
05DC:  BSF    03.6
05DD:  MOVWF  0D
05DE:  MOVLW  00
05DF:  MOVWF  0F
05E0:  BCF    03.6
05E1:  CALL   100
....................    int g; 
....................    int f; 
....................    WHILE(TRUE) 
....................    { 
....................       int i = 0;//val del vector 
05E2:  CLRF   37
....................       DIR=9; 
05E3:  MOVLW  09
05E4:  MOVWF  30
....................       LCD_GOTOXY(1,2);  //Ubica el cursor del LCD 
05E5:  MOVLW  01
05E6:  MOVWF  4A
05E7:  MOVLW  02
05E8:  MOVWF  4B
05E9:  CALL   0C9
....................       LCD_PUTC("Temp. A= "); 
05EA:  MOVLW  26
05EB:  BSF    03.6
05EC:  MOVWF  0D
05ED:  MOVLW  00
05EE:  MOVWF  0F
05EF:  BCF    03.6
05F0:  CALL   100
....................       LCD_GOTOXY(1,2);  //Ubica el cursor del LCD 
05F1:  MOVLW  01
05F2:  MOVWF  4A
05F3:  MOVLW  02
05F4:  MOVWF  4B
05F5:  CALL   0C9
....................       aux="";//valor auxiliar para comparar temperatura iniciado en 100 para que se apague el ventilador 
05F6:  CLRF   3C
05F7:  CLRF   3D
05F8:  MOVLW  33
05F9:  MOVWF  04
05FA:  BCF    03.7
05FB:  MOVF   3C,W
05FC:  ADDWF  04,F
05FD:  MOVF   3D,W
05FE:  CALL   020
05FF:  MOVWF  00
0600:  IORLW  00
0601:  BTFSC  03.2
0602:  GOTO   606
0603:  INCF   3D,F
0604:  INCF   3C,F
0605:  GOTO   5F8
....................       while (DIR < 17) 
....................       { 
0606:  MOVF   30,W
0607:  SUBLW  10
0608:  BTFSS  03.0
0609:  GOTO   70C
....................             if(DIR <= 10){ 
060A:  MOVF   30,W
060B:  SUBLW  0A
060C:  BTFSS  03.0
060D:  GOTO   62D
....................                if(k!='\0'){ 
060E:  MOVF   32,F
060F:  BTFSC  03.2
0610:  GOTO   62C
....................                    
....................                   if (k == '*' || k == '#'){ 
0611:  MOVF   32,W
0612:  SUBLW  2A
0613:  BTFSC  03.2
0614:  GOTO   619
0615:  MOVF   32,W
0616:  SUBLW  23
0617:  BTFSS  03.2
0618:  GOTO   61B
....................                      k='\0'; 
0619:  CLRF   32
....................                   } 
....................                    
....................                   else{ 
061A:  GOTO   62C
....................                      LCD_GOTOXY(DIR,2); 
061B:  MOVF   30,W
061C:  MOVWF  4A
061D:  MOVLW  02
061E:  MOVWF  4B
061F:  CALL   0C9
....................                      lcd_putc(k); 
0620:  MOVF   32,W
0621:  MOVWF  49
0622:  CALL   0DB
....................                      aux [i]= k;//guardando los datos de teclado en variable auxiliar 
0623:  MOVLW  33
0624:  ADDWF  37,W
0625:  MOVWF  04
0626:  BCF    03.7
0627:  MOVF   32,W
0628:  MOVWF  00
....................                      i++;//incrementador del puntero de la variable auxiliar 
0629:  INCF   37,F
....................                      k='\0'; 
062A:  CLRF   32
....................                      DIR++; 
062B:  INCF   30,F
....................                       
....................                   } 
....................                    
....................                } 
....................             }else if(k=='#'){ 
062C:  GOTO   634
062D:  MOVF   32,W
062E:  SUBLW  23
062F:  BTFSS  03.2
0630:  GOTO   634
....................                      k='\0'; 
0631:  CLRF   32
....................                      DIR = 17; 
0632:  MOVLW  11
0633:  MOVWF  30
....................                   } 
....................          
....................           
....................  // ============================================================================= //         
....................          //A continuacin se muestran diferentes formas para leer los valores 
....................          //del teclado matricial, descomenta la forma de almacenar el dato 
....................          //en la variable "k" y observa las diferencias de cada llamado 
....................           
....................           
....................           
....................          //k=tecla();      //Lee el valor del teclado y espera hasta que alguna tecla se pulse 
....................          k=tecla_time();   //Lee el valor del teclado pero solo espera un tiempo determinado 
0634:  GOTO   1B6
0635:  MOVF   78,W
0636:  MOVWF  32
....................          //k=kbd_getc();   //Funcin del ccs c para leer el valor del teclado (sin control) 
....................           
....................   // ============================================================================= //    
....................          if(DIR>16) 
0637:  MOVF   30,W
0638:  SUBLW  10
0639:  BTFSC  03.0
063A:  GOTO   642
....................             LCD_PUTC("\f"); 
063B:  MOVLW  2B
063C:  BSF    03.6
063D:  MOVWF  0D
063E:  MOVLW  00
063F:  MOVWF  0F
0640:  BCF    03.6
0641:  CALL   100
....................           
....................        //Lectura ADC 
....................         set_adc_channel(0);          //Selecciono el canal 0 (RA0) 
0642:  MOVLW  00
0643:  MOVWF  78
0644:  MOVF   1F,W
0645:  ANDLW  C3
0646:  IORWF  78,W
0647:  MOVWF  1F
....................         delay_ms(1);                 //llamo retardo de 1 ms 
0648:  MOVLW  01
0649:  MOVWF  4A
064A:  CALL   034
....................         bits=read_adc();             //Guarde el dato de la Termocupla en tempe 
064B:  BSF    1F.1
064C:  BTFSC  1F.1
064D:  GOTO   64C
064E:  BSF    03.5
064F:  MOVF   1E,W
0650:  BCF    03.5
0651:  MOVWF  2A
0652:  MOVF   1E,W
0653:  MOVWF  2B
....................         tem=(bits*0.0587450184);  //Conversion de bits a temperatura, aadido mas para aumentar la presision con la termocupla del tester 
0654:  MOVF   2B,W
0655:  MOVWF  3D
0656:  MOVF   2A,W
0657:  MOVWF  3C
0658:  GOTO   1D9
0659:  MOVF   7A,W
065A:  MOVWF  4C
065B:  MOVF   79,W
065C:  MOVWF  4B
065D:  MOVF   78,W
065E:  MOVWF  4A
065F:  MOVF   77,W
0660:  MOVWF  49
0661:  MOVLW  9E
0662:  MOVWF  50
0663:  MOVWF  4F
0664:  MOVLW  70
0665:  MOVWF  4E
0666:  MOVLW  7A
0667:  MOVWF  4D
0668:  CALL   1F8
0669:  MOVF   7A,W
066A:  MOVWF  2F
066B:  MOVF   79,W
066C:  MOVWF  2E
066D:  MOVF   78,W
066E:  MOVWF  2D
066F:  MOVF   77,W
0670:  MOVWF  2C
....................         lcd_gotoxy(1,1);             //Ubiquese en la posicion 2,2 
0671:  MOVLW  01
0672:  MOVWF  4A
0673:  MOVWF  4B
0674:  CALL   0C9
....................         printf(lcd_putc,"Temp. R= %f    ",tem);  //Muestra el valor numerico de la conversion 
0675:  MOVLW  2C
0676:  BSF    03.6
0677:  MOVWF  0D
0678:  MOVLW  00
0679:  MOVWF  0F
067A:  BCF    03.0
067B:  MOVLW  09
067C:  BCF    03.6
067D:  MOVWF  3C
067E:  CALL   26D
067F:  MOVLW  89
0680:  MOVWF  04
0681:  MOVF   2F,W
0682:  MOVWF  3F
0683:  MOVF   2E,W
0684:  MOVWF  3E
0685:  MOVF   2D,W
0686:  MOVWF  3D
0687:  MOVF   2C,W
0688:  MOVWF  3C
0689:  MOVLW  02
068A:  MOVWF  40
068B:  GOTO   2FD
068C:  MOVLW  31
068D:  BSF    03.6
068E:  MOVWF  0D
068F:  MOVLW  00
0690:  MOVWF  0F
0691:  BSF    03.0
0692:  MOVLW  04
0693:  BCF    03.6
0694:  MOVWF  3C
0695:  CALL   26D
....................          
....................          
....................              //Codigo del ventilador 
....................         float comp = atol(aux); 
0696:  CLRF   3D
0697:  MOVLW  33
0698:  MOVWF  3C
0699:  GOTO   3E6
069A:  MOVF   79,W
069B:  MOVWF  3D
069C:  MOVF   78,W
069D:  MOVWF  3C
069E:  GOTO   51C
069F:  MOVF   7A,W
06A0:  MOVWF  3B
06A1:  MOVF   79,W
06A2:  MOVWF  3A
06A3:  MOVF   78,W
06A4:  MOVWF  39
06A5:  MOVF   77,W
06A6:  MOVWF  38
....................         g=(int)comp; 
06A7:  MOVF   3B,W
06A8:  MOVWF  3F
06A9:  MOVF   3A,W
06AA:  MOVWF  3E
06AB:  MOVF   39,W
06AC:  MOVWF  3D
06AD:  MOVF   38,W
06AE:  MOVWF  3C
06AF:  CALL   543
06B0:  MOVF   78,W
06B1:  MOVWF  35
....................         f=(int)tem; 
06B2:  MOVF   2F,W
06B3:  MOVWF  3F
06B4:  MOVF   2E,W
06B5:  MOVWF  3E
06B6:  MOVF   2D,W
06B7:  MOVWF  3D
06B8:  MOVF   2C,W
06B9:  MOVWF  3C
06BA:  CALL   543
06BB:  MOVF   78,W
06BC:  MOVWF  36
....................           if((g==f+2)||(g==f-2) 
....................            
....................           ||(g==f)){ 
06BD:  MOVLW  02
06BE:  ADDWF  36,W
06BF:  SUBWF  35,W
06C0:  BTFSC  03.2
06C1:  GOTO   6CB
06C2:  MOVLW  02
06C3:  SUBWF  36,W
06C4:  SUBWF  35,W
06C5:  BTFSC  03.2
06C6:  GOTO   6CB
06C7:  MOVF   36,W
06C8:  SUBWF  35,W
06C9:  BTFSS  03.2
06CA:  GOTO   6D4
....................           output_low(foco); 
06CB:  BSF    03.5
06CC:  BCF    05.3
06CD:  BCF    03.5
06CE:  BCF    05.3
....................           output_high(motor); 
06CF:  BSF    03.5
06D0:  BCF    05.2
06D1:  BCF    03.5
06D2:  BSF    05.2
....................          
....................           } 
....................          else if(tem > comp){                       // comparacion de la temperatura real a la temperatura ajustada 
06D3:  GOTO   70B
06D4:  MOVF   3B,W
06D5:  MOVWF  3F
06D6:  MOVF   3A,W
06D7:  MOVWF  3E
06D8:  MOVF   39,W
06D9:  MOVWF  3D
06DA:  MOVF   38,W
06DB:  MOVWF  3C
06DC:  MOVF   2F,W
06DD:  MOVWF  43
06DE:  MOVF   2E,W
06DF:  MOVWF  42
06E0:  MOVF   2D,W
06E1:  MOVWF  41
06E2:  MOVF   2C,W
06E3:  MOVWF  40
06E4:  CALL   562
06E5:  BTFSS  03.0
06E6:  GOTO   6F0
....................             output_high(foco);//Una vez que el ventilador se encienda el "foco" o led se apagara 
06E7:  BSF    03.5
06E8:  BCF    05.3
06E9:  BCF    03.5
06EA:  BSF    05.3
....................             output_high(motor);//encendera ventelidar en caso de sobre pasar la ajustada 
06EB:  BSF    03.5
06EC:  BCF    05.2
06ED:  BCF    03.5
06EE:  BSF    05.2
....................          }else if (tem < comp){             
06EF:  GOTO   70B
06F0:  MOVF   2F,W
06F1:  MOVWF  3F
06F2:  MOVF   2E,W
06F3:  MOVWF  3E
06F4:  MOVF   2D,W
06F5:  MOVWF  3D
06F6:  MOVF   2C,W
06F7:  MOVWF  3C
06F8:  MOVF   3B,W
06F9:  MOVWF  43
06FA:  MOVF   3A,W
06FB:  MOVWF  42
06FC:  MOVF   39,W
06FD:  MOVWF  41
06FE:  MOVF   38,W
06FF:  MOVWF  40
0700:  CALL   562
0701:  BTFSS  03.0
0702:  GOTO   70B
....................             output_low(foco);//*********_________________Luego que el ventilador se apaga por el enfriamiento Encenderemos de nuevo el led o "foco" 
0703:  BSF    03.5
0704:  BCF    05.3
0705:  BCF    03.5
0706:  BCF    05.3
....................             output_low(motor);//de lo contrario la apagara  
0707:  BSF    03.5
0708:  BCF    05.2
0709:  BCF    03.5
070A:  BCF    05.2
....................          } 
....................        } 
070B:  GOTO   606
....................              
....................       } 
070C:  GOTO   5E2
....................        
....................    } 
....................  
070D:  SLEEP

Configuration Fuses:
   Word  1: 2CF1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
